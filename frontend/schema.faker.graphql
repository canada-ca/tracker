"""
A field whose value is an upper case letter or an under score that has a
length between 1 and 50
"""
scalar Acronym @examples(values: ["GC", "ABC", "ASDF", "NSTIR", "BC"])

"""
DMARC operates by checking that the domain in the message's From: field
(also called "5322.From") is "aligned" with other authenticated domain
names. If either SPF or DKIM alignment checks pass, then the DMARC alignment
test passes.
"""
type Alignment {
  """
  Is SPF aligned
  """
  spf: Boolean

  """
  Is DKIM aligned
  """
  dkim: Boolean

  """
  Is DMARC aligned
  """
  dmarc: Boolean
}

"""
This mutation allows users to give their credentials and retrieve a token
that gives them access to restricted content.
"""
type Authenticate {
  """
  User info who just signed in, and their JWT
  """
  authResult: AuthResult
}

"""
Object containing input fields for Authenticate Mutation
"""
input AuthenticateInput {
  """
  User email that they signed up with.
  """
  userName: EmailAddress!

  """
  Users password
  """
  password: String!
}

"""
A type used to return information when users sign up or authenticate
"""
type AuthResult {
  """
  JWT used for accessing, controlled content.
  """
  authToken: String

  """
  User that has just been created or signed in
  """
  user: User
}

"""
This object displays the total amount of messages that fit into each category
"""
type CategoryTotals {
  """
  Amount of messages that passed all checks
  """
  fullPass: Int

  """
  Amount of messages that passed some checks
  """
  partialPass: Int

  """
  Amount of messages that failed all checks
  """
  fail: Int

  """
  The sum of all different categories.
  """
  total: Int
}
"""
This class handles the inner nested dict given by key: 'content'.
"""
type Content {
  body: String
  fromEmail: String
  subject: String
}

"""
Mutation used to create a new domain for an organization
"""
type CreateDomain {
  status: Boolean
}

"""
Input object used to define the argument fields for the createDomain
mutation
"""
input CreateDomainInput {
  """
  Organizations slug that you would like to connect this domain to.
  """
  orgSlug: Slug!

  """
  URL that you would like to be added to database.
  """
  url: URL!

  """
  DKIM selector strings corresponding to this domain
  """
  selectors: Selectors
}

"""
Mutation allows the creation of an organization inside the database.
"""
type CreateOrganization {
  status: Boolean
}

"""
Input object type containing all the fields for the create organization
mutation
"""
input CreateOrganizationInput {
  """
  Acronym of organization.
  """
  acronym: Acronym!

  """
  Full name of organization.
  """
  name: String!

  """
  The zone which the organization belongs to.
  """
  zone: String!

  """
  The sector which the organization belongs to.
  """
  sector: String!

  """
  The province in which the organization is located in.
  """
  province: String!

  """
  The city in which the organization is located in.
  """
  city: String!
}

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""
Object that contains the details for each category
"""
type DetailTables {
  """
  List of top senders that have full pass
  """
  fullPass: [TableStructure] @listLength(min: 20, max: 30)

  """
  List of top senders that have an spf failure
  """
  spfFailure: [TableStructure] @listLength(min: 20, max: 30)

  """
  List of top senders that have spf misaligned
  """
  spfMisaligned: [TableStructure] @listLength(min: 20, max: 30)

  """
  List of top senders that have an dkim failure
  """
  dkimFailure: [TableStructure] @listLength(min: 20, max: 30)

  """
  List of top senders that have dkim misaligned
  """
  dkimMisaligned: [TableStructure] @listLength(min: 20, max: 30)

  """
  List of top senders that have an dmarc failure
  """
  dmarcFailure: [TableStructure] @listLength(min: 20, max: 30)
}

"""
DomainKeys Identified Mail (DKIM) permits a person, role, or
organization that owns the signing domain to claim some
responsibility for a message by associating the domain with the
message.  This can be an author's organization, an operational relay,
or one of their agents.
"""
type DKIM {
  """
  ID of the object
  """
  id: ID
  """
  The domain the scan was run on
  """
  domain: URL @fake(type: domainName)
  """
  Time when scan was initiated
  """
  timestamp: DateTime @fake(type: pastDate)
  """
  Various dkim selectors used on this domain.
  """
  selectors: [DkimSelectors]

}

"""
This object contains the scan result data for each individual selector that
has been scanned.
"""
type DkimSelectors {
  """
  Selector domain that has been scanned.
  """
  selector: String @examples(values: ["selector1._domainkey", "selector2._domainkey"])
  """
  DKIM record retrieved during the scan of the given domain
  """
  record: String
    @examples(
      values: [
        "v=DKIM1; k=rsa; p=MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC3rvAQg9bl72tae1RFu4zdx1ZE4E8VUbQfxDcm;"
      ]
    )
  """
  Length of DKIM public key
  """
  keyLength: String @examples(values: ["sub1024", "1024", "2048", "2048plus"])
  """
  Key tags found during scan
  """
  dkimGuidanceTags: [String]
    @examples(
      values: [
        "dkim1"
        "dkim2"
        "dkim3"
        "dkim4"
        "dkim5"
        "dkim6"
        "dkim7"
        "dkim8"
        "dkim9"
        "dkim10"
        "dkim11"
        "dkim12"
        "dkim13"
      ]
    )
}

"""
Domain-based Message Authentication, Reporting, and Conformance
(DMARC) is a scalable mechanism by which a mail-originating
organization can express domain-level policies and preferences for
message validation, disposition, and reporting, that a mail-receiving
organization can use to improve mail handling.
"""
type DMARC {
  """
  ID of the object
  """
  id: ID
  """
  The domain the scan was run on
  """
  domain: URL @fake(type: domainName)
  """
  Time when scan was initiated
  """
  timestamp: DateTime @fake(type: pastDate)
  """
  DMARC Phase found when running scan
  """
  dmarcPhase: Int
  """
  DMARC record retrieved during the scan of the given domain
  """
  record: String
    @examples(
      values: [
        "v=DMARC1; p=none; pct=100; rua=mailto:dmarc@cyber.gc.ca; ruf=mailto:dmarc@cyber.gc.ca; fo=1"
        "v=DMARC1; p=none; sp=none; rua=mailto:dmarc@cyber.gc.ca"
      ]
    )
  """
  The requested policy you wish mailbox providers to apply when your email fails DMARC authentication and alignment checks.
  """
  pPolicy: String @examples(values: ["none", "missing", "quarantine", "reject"])
  """
  This tag is used to indicate a requested policy for all subdomains where mail
  is failing the DMARC authentication and alignment checks.
  """
  spPolicy: String
    @examples(values: ["none", "missing", "quarantine", "reject"])
  """
  The percentage of messages to which the DMARC policy is to be applied.
  """
  pct: Int @examples(values: [0, 20, 60, 70, 90, 100])

  """
  Key tags found during DMARC Scan
  """
  dmarcGuidanceTags: [String]
    @examples(
      values: [
        "dmarc1"
        "dmarc2"
        "dmarc3"
        "dmarc4"
        "dmarc5"
        "dmarc6"
        "dmarc7"
        "dmarc8"
        "dmarc9"
        "dmarc10"
        "dmarc11"
        "dmarc12"
        "dmarc13"
        "dmarc14"
        "dmarc15"
        "dmarc16"
        "dmarc17"
        "dmarc18"
        "dmarc19"
        "dmarc20"
        "dmarc21"
        "dmarc22"
      ]
    )
}

"""
GraphQL object for returning data for dmarc report tables
"""
type DmarcReportDetailTables {
  """
  The month in which the data is relevant to.
  """
  month: PeriodEnums

  """
  The year in which the relevant to.
  """
  year: Year

  """
  The details used in creating tables for the dmarc report page
  """
  detailTables: DetailTables
}

"""
Input object containing fields which map to the required arguments for
dmarcReportDetailTablesInput
"""
input DmarcReportDetailTablesInput {
  """
  The slugified version of the domain you wish to retrieve data for.
  """
  domainSlug: Slug!

  """
  The period in which the returned data is relevant to.
  """
  period: PeriodEnums!

  """
  The year in which the returned data is relevant to.
  """
  year: Year!
}

"""
A query object used to grab the data to create dmarc report doughnuts
"""
type DmarcReportSummary {
  """
  Which month is the data based on.
  """
  month: PeriodEnums

  """
  Which year the data is from.
  """
  year: Year

  """
  Category totals for building dmarc report page doughnuts.
  """
  categoryTotals: CategoryTotals
}

"""
This object is used to define the various arguments used in the dmarc report
summary query
"""
input DmarcReportSummaryInput {
  """The slugified version of the domain you wish to retrieve data for."""
  domainSlug: Slug!

  """The period in which the returned data is relevant to."""
  period: PeriodEnums!

  """The year in which the returned data is relevant to."""
  year: Year!
}

"""
A query object used to grab the data to create dmarc report bar graph
"""
type DmarcReportSummaryList {
  """
  The month that the data is related to.
  """
  month: PeriodEnums

  """
  The year that the data is related to.
  """
  year: Year @examples(values: [2019, 2020])

  """
  Category totals for building dmarc report page bar graph.
  """
  categoryTotals: CategoryTotals
}

"""
This object is used to define the various arguments used in the dmarc report
summary list query
"""
input DmarcReportSummaryListInput {
  """The slugified version of the domain you wish to retrieve data for."""
  domainSlug: Slug!
}

type Domain implements Node {
  organization: Organizations

  """
  The ID of the object.
  """
  id: ID!

  """
  The domain the scan was run on
  """
  url: URL
    @examples(
      values: [
        "javascript:alert('XSS')"
        "javascript:eval('aler'+(!![]+[])[+[]])('xss')"
        "rcmp-grc.gc.ca"
        "tbs-sct.gc.ca"
        "canada.ca"
        "cra-arc.gc.ca"
        "pm.gc.ca"
        "cse-cst.gc.ca"
        "forces.gc.ca"
        "jAva&Tab;script:alert('XSS')"
        "cra.arc.gc.ca"
        "cra-arc.gc.ca"
        "cse-cst.gc.ca"
        "cyber.gc.ca"
        "dfait-maeci.gc.ca"
        "dfo-mpo.gc.ca"
        "ec.gc.ca"
        "forces.gc.ca"
        "gccollab.ca"
        "gccollaboration.ca"
        "goc-gdc.ca"
        "hc-sc.gc.ca"
      ]
    )

  """
  Slug of the url
  """
  slug: Slug

  """
  The last time that a scan was ran on this domain
  """
  lastRan: DateTime @fake(type: recentDate)

  """
  DKIM, DMARC, and SPF scan results
  """
  email(
    before: String
    after: String
    first: Int
    last: Int
  ): MailScanConnection
  """
  HTTPS, and SSL scan results
  """
  web(before: String, after: String, first: Int, last: Int): WebScanConnection
}

type DomainConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [DomainEdge]!
}
"""
A Relay edge containing a `Domain` and its cursor.
"""
type DomainEdge {
  """
  The item at the end of the edge
  """
  node: Domain
  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
A field whose value conforms to the standard internet email address format as specified in RFC822:
https://www.w3.org/Protocols/rfc822/.
"""
scalar EmailAddress

"""
Results of DKIM, DMARC, and SPF scans, on domains
"""
type MailScan implements Node {
  """
  The domain the scan was run on
  """
  domain: URL @fake(type: domainName)

  """
  The ID of the object.
  """
  id: ID!

  """
  The time the scan was initiated
  """
  timestamp: DateTime @fake(type: pastDate)

  """
  Domain-based Message Authentication, Reporting, and Conformance (DMARC)
  """
  dmarc: DMARC

  """
  Sender Policy Framework (SPF) for Authorizing Use of Domains in Email
  """
  spf: SPF

  """
  DomainKeys Identified Mail (DKIM) Signatures
  """
  dkim: DKIM
}

type MailScanConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [MailScanEdge]!
}

"""
A Relay edge containing a `MailScan` and its cursor.
"""
type MailScanEdge {
  """
  The item at the end of the edge
  """
  node: MailScan

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
Mutation that allows the user to verify their account through a token
sent in an email
"""
type EmailVerifyAccount {
  """
  Informs user if account was successfully verified.
  """
  status: Boolean
}

"""
Http Scan Object
"""
type HTTPS {
  """
  The ID of the object
  """
  id: ID

  """
  The domain the scan was run on
  """
  domain: URL

  """
  The time the scan was initiated
  """
  timestamp: DateTime

  """
  State of the HTTPS implementation on the server and any issues therein
  """
  implementation: String

  """
  Degree to which HTTPS is enforced on the server based on behaviour
  """
  enforced: String

  """
  Presence and completeness of HSTS implementation
  """
  hsts: String

  """
  Denotes how long the domain should only be accessed using HTTPS
  """
  hstsAge: String

  """
  Denotes whether the domain has been submitted and included within HSTS preload list
  """
  preloaded: String

  httpsGuidanceTags: [String]
    @examples(
      values: [
        "https1"
        "https2"
        "https3"
        "https4"
        "https5"
        "https6"
        "https7"
        "https8"
        "https9"
        "https10"
        "https11"
        "https12"
        "https13"
        "https14"
      ]
    )
}

"""
Identifiers identify a domain name to be authenticated
"""
type Identifiers {
  """
  the domain DMARC uses to check alignment with SPF/DKIM
  """
  headerFrom: String @examples(values: ["example.com"])

  """
  SPF domain used to check alignment
  """
  envelopeFrom: String @examples(values: ["example.com"])

  """
  "Envelope Recipient" in the email header
  """
  envelopeTo: String @examples(values: ["fastmail.fm"])
}

enum LanguageEnums {
  """
  Used for defining if English is the preferred language
  """
  ENGLISH

  """
  Used for defining if French is the preferred language
  """
  FRENCH
}

"""
The central gathering point for all of the GraphQL mutations.
"""
type Mutation {
  updatePassword(
    confirmPassword: String!
    password: String!
    userName: EmailAddress!
  ): UpdateUserPassword
  authenticateTwoFactor(
    otpCode: String!
    userName: EmailAddress!
  ): ValidateTwoFactor
  updateUserRole(
    orgSlug: Slug!
    role: RoleEnums!
    userName: EmailAddress!
  ): UpdateUserRole

  """
  Allows the creation of an organization inside the database.
  """
  createOrganization(
    """
    Input object containing all the fields required for the createOrganization mutation
    """
    input: CreateOrganizationInput!
  ): CreateOrganization

  """
  Allows modification of an organization inside the database.
  """
  updateOrganization(
    """
    Organization Acronym you would like updated
    """
    acronym: Acronym

    """
    The city in which the organization is located in.
    """
    city: String

    """
    Full name of organization.
    """
    name: String

    """
    The province in which the organization is located in.
    """
    province: String

    """
    The sector which the organization belongs to.
    """
    sector: String

    """
    Organization that will be updated
    """
    slug: Slug!

    """
    The zone which the organization belongs to.
    """
    zone: String
  ): UpdateOrganization

  """
  Allows the removal of an organization inside the database
  """
  removeOrganization(
    """
    The organization you wish to remove
    """
    slug: Slug!
  ): RemoveOrganization

  """
  Allows the creation of domains for a given organization
  """
  createDomain(
    """
    Input object containing all arguement fields.
    """
    input: CreateDomainInput!
  ): CreateDomain

  """
  Allows the modification of domains
  """
  updateDomain(
    """
    The current domain that is being requested to be updated.
    """
    currentUrl: URL!

    """
    The new DKIM selector strings corresponding to this domain
    """
    updatedSelectors: Selectors

    """
    The new domain you wish to update the current domain to be.
    """
    updatedUrl: URL!
  ): UpdateDomain

  """
  Allows the removal of a given domain
  """
  removeDomain(
    """
    URL of domain that is being removed
    """
    url: URL!
  ): RemoveDomain

  """
  This mutation is used to send a domain to the scanners to be scanned
  """
  requestScan(
    """
    Input object with fields used for requesting mutation
    """
    input: RequestScanInput!
  ): RequestScan

  """
  Allows users to give their credentials and be authenticated
  """
  authenticate(
    """
    AuthenticateInput object containing input fields
    """
    input: AuthenticateInput!
  ): Authenticate

  """
  Allows users to sign up to our service
  """
  signUp(
    """
    A confirmation that the user submitted the correct password
    """
    confirmPassword: String!

    """
    The name that will be displayed to other users.
    """
    displayName: String!

    """
    The password the user will authenticate with
    """
    password: String!

    """
    Used to set users preferred language
    """
    preferredLang: LanguageEnums!

    """
    Email address that the user will use to authenticate with
    """
    userName: EmailAddress!
  ): SignUp

  """
  Allows users to use token sent through email to verify their account.
  """
  emailVerifyAccount(
    """
    Token in sent via email, and located in url
    """
    tokenString: String!
  ): EmailVerifyAccount

  """
  Allows users to resend verification if failed during sign-up
  """
  sendEmailVerification(
    """
    The users email address used for sending email
    """
    userName: EmailAddress!
  ): SendEmailVerification
}

"""
An object with an ID
"""
interface Node {
  """
  The ID of the object.
  """
  id: ID!
}

"""
This class contains all of the fields for the entire dict given
as a response to the Notify client sending it's email
"""
type NotificationEmail {
  content: Content
  id: String
  reference: String
  scheduledFor: String
  template: Template
  uri: String
}

type OrganizationDetail {
  """
  The ID of the object.
  """
  id: ID!

  """
  The acronym of the organization.
  """
  acronym: Acronym

  """
  The full name of the organization.
  """
  name: String @fake(type: companyName)

  """
  Slug of the organizations name
  """
  slug: Slug
    @examples(
      values: [
        "treasury-board-secretariat"
        "environment-canada"
        "health-canada"
        "canada-revenue-agency"
        "fisheries-and-oceans-canada"
      ]
    )

  """
  The number of domains under this organization
  """
  domainCount: Int
    @fake(
      type: number
      options: { minNumber: 0, maxNumber: 20, precisionNumber: 1 }
    )

  """
  The zone which the organization belongs to.
  """
  zone: String

  """
  The sector which the organizaion belongs to.
  """
  sector: String @examples(values: ["government", "energy", "research"])

  """
  The province in which the organization resides.
  """
  province: String @examples(values: ["Ontario", "Nova Scotia", "Quebec"])

  """
  The city in which the organization resides.
  """
  city: String @examples(values: ["Ottawa", "Halifax", "Montreal"])

  """
  The domains which belong to this organization.
  """
  domains(
    before: String
    after: String
    first: Int
    last: Int
  ): DomainConnection
}

type Organizations implements Node {
  """
  The number of domains under this organization
  """
  domainCount: Int
    @fake(
      type: number
      options: { minNumber: 0, maxNumber: 20, precisionNumber: 1 }
    )
  """
  The ID of the object.
  """
  id: ID!

  """
  The acronym of the organization.
  """
  acronym: Acronym

  """
  The full name of the organization.
  """
  name: String @fake(type: companyName)

  """
  Slug of the organizations name
  """
  slug: Slug
    @examples(
      values: [
        "treasury-board-secretariat"
        "environment-canada"
        "health-canada"
        "canada-revenue-agency"
        "fisheries-and-oceans-canada"
      ]
    )

  """
  The zone which the organization belongs to.
  """
  zone: String

  """
  The sector which the organizaion belongs to.
  """
  sector: String

  """
  The province in which the organization resides.
  """
  province: String @examples(values: ["Ontario", "Nova Scotia", "Quebec"])

  """
  The city in which the organization resides.
  """
  city: String @examples(values: ["Ottawa", "Halifax", "Montreal"])

  """
  The domains which belong to this organization.
  """
  domains(
    before: String
    after: String
    first: Int
    last: Int
  ): DomainConnection

  """
  The users that have an affiliation with the organization.
  """
  affiliatedUsers(
    before: String
    after: String
    first: Int
    last: Int
  ): UserAffClassConnection
}

type OrganizationsConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [OrganizationsEdge]!
}

"""
A Relay edge containing a `Organizations` and its cursor.
"""
type OrganizationsEdge {
  """
  The item at the end of the edge
  """
  node: Organizations

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean! @examples(values: [true, false])

  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean! @examples(values: [true, false])

  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: String

  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: String
}

enum PeriodEnums {
  """
  The month of January
  """
  JANUARY

  """
  The month of February
  """
  FEBRUARY

  """
  The month of March
  """
  MARCH

  """
  The month of April
  """
  APRIL

  """
  The month of May
  """
  MAY

  """
  The month of June
  """
  JUNE

  """
  The month of July
  """
  JULY

  """
  The month of August
  """
  AUGUST

  """
  The month of September
  """
  SEPTEMBER

  """
  The month of October
  """
  OCTOBER

  """
  The month of November
  """
  NOVEMBER

  """
  The month of December
  """
  DECEMBER

  """
  The last 30 days
  """
  LAST30DAYS
}

"""
Policies evaluated
"""
type PolicyEvaluated {
  """
  Tells mail receivers what do do with messages that do not pass your rules
  """
  disposition: String @examples(values: ["none"])

  """
  DKIM pass/fail
  """
  dkim: String @examples(values: ["fail"])

  """
  SPF pass/fail
  """
  spf: String @examples(values: ["fail"])

  """
  List of policy override reasons
  """
  policyOverrideReasons: [String]
}

"""
Domains published policy
"""
type PolicyPublished {
  """
  Domain report was generated from
  """
  domain: URL @examples(values: ["example.com"])

  """
  DKIM alignment mode
  """
  adkim: String @examples(values: ["r"])

  """
  SPF alignment mode
  """
  aspf: String @examples(values: ["r"])

  """
  P Policy
  """
  p: String @examples(values: ["none"])

  """
  SP Policy
  """
  sp: String @examples(values: ["none"])

  """
  DMARC Percentage
  """
  pct: Int @examples(values: [0, 10, 20, 50, 100])

  """
  Lets mailbox providers knows if you want sample messages that failed either SPF or DKIM
  """
  fo: Int @examples(values: [0])
}

type SummaryCategory {
  name: String @examples(values: ["strong", "moderate", "weak"])
  count: Int @examples(values: [33, 33, 33])
  percentage: Int @examples(values: [33, 33, 33])
}

type CategorizedSummary {
  categories: [SummaryCategory]
  total: Int @examples(values: [100])
}

"""
The central gathering point for all of the GraphQL queries.
"""
type Query {
  webSummary: CategorizedSummary
  emailSummary: CategorizedSummary
  """
  A query object used to grab the data to create dmarc report bar graph.
  """
  dmarcReportSummaryList(
    """
    Input argument with various input fields required for the dmarc report summary list query
    """
    input: DmarcReportSummaryListInput!
  ): [DmarcReportSummaryList] @listLength(min: 13, max: 13)

  """
  A query object used to grab the data to create dmarc report bar graph.
  """
  demoDmarcReportSummaryList(
    """
    Input argument with various input fields required for the dmarc report summary list query
    """
    input: DmarcReportSummaryListInput!
  ): [DmarcReportSummaryList] @listLength(min: 13, max: 13)

  """
  Query used for gathering data for dmarc report detail tables.
  """
  dmarcReportDetailTables(
    """
    Input object containing fields which map to the required arguments for dmarcReportDetailTablesInput
    """
    input: DmarcReportDetailTablesInput!
  ): DmarcReportDetailTables

  """
  Query used for gathering data for dmarc report detail tables.
  """
  demoDmarcReportDetailTables(
    """
    Input object containing fields which map to the required arguments for dmarcReportDetailTablesInput
    """
    input: DmarcReportDetailTablesInput!
  ): DmarcReportDetailTables

  """A query object used to grab the data to create dmarc report doughnuts"""
  dmarcReportSummary(
    """
    Input argument with various input fields required for the dmarc report summary query
    """
    input: DmarcReportSummaryInput!
  ): DmarcReportSummary

  """A query object used to grab the data to create dmarc report doughnuts"""
  demoDmarcReportSummary(
    """
    Input argument with various input fields required for the dmarc report summary query
    """
    input: DmarcReportSummaryInput!
  ): DmarcReportSummary

  """
  An graphql object that will be used to populate a userList component in the front end
  """
  userList(
    orgSlug: Slug!
    before: String
    after: String
    first: Int
    last: Int
  ): UserListItemConnection

  """
  An graphql object that will be used to populate a userPage component in the front end
  """
  userPage(
    """
    Users user name/email address
    """
    userName: EmailAddress
  ): UserPage

  """
  The ID of the object
  """
  node(id: ID!): Node

  """
  Query the currently logged in user if no user name isgiven, or query a specific user by user name.
  """
  user(userName: EmailAddress): [User]

  """
  Select all information on a selected organization that a user has access to.
  """
  findOrganizationDetailBySlug(slug: Slug!): OrganizationDetail

  """
  Select all information on all organizations that a user has access to.
  """
  findMyOrganizations(
    before: String
    after: String
    first: Int
    last: Int
  ): OrganizationsConnection

  """
  Select information on a specific domain.
  """
  findDomainBySlug(urlSlug: Slug!): Domain

  """
  Select information on an organizations domains, or all domains a user has access to.
  """
  findDomainsByOrg(
    orgSlug: Slug
    before: String
    after: String
    first: Int
    last: Int
  ): DomainConnection

  """
  Select information on  all domains a user has access to.
  """
  findMyDomains(
    before: String
    after: String
    first: Int
    last: Int
  ): DomainConnection

  """
  An api endpoint used to generate a OTP url used for two factor authentication.
  """
  generateOtpUrl(email: EmailAddress!): String
    @examples(
      values: [
        "otpauth://totp/Secure%20App:alice%40google.com?secret=JBSWY3DPEHPK3PXP&issuer=Secure%20App"
      ]
    )

  """
  An api endpoint to view a current user's claims -- Requires an active JWT.
  """
  testUserClaims(orgSlug: Slug!, role: RoleEnums!): String

  """
  An api endpoint that will send an email to a given email address so a user can reset their password for the web app.
  """
  sendPasswordReset(email: EmailAddress!): NotificationEmail

  """
  An api endpoint that will send a verification email to a given email address.
  """
  sendValidationEmail(email: EmailAddress!): NotificationEmail
}

"""
This mutation allows the removal of unused domains
"""
type RemoveDomain {
  status: Boolean
}

"""
Mutation allows the removal of an organization inside the database.
"""
type RemoveOrganization {
  status: Boolean
}

"""
This mutation is used to send a domain to the scanners to be scanned
"""
type RequestScan {
  requestStatus: String
}

"""
This Object is used to create fields for the RequestScan Mutation
"""
input RequestScanInput {
  """
  The domain that you would like the scan to be ran on.
  """
  urlSlug: Slug!

  """
  Type of scan to perform on designated domain ('Web' or 'Mail').
  """
  scanType: ScanTypeEnums!
}

enum RoleEnums {
  """
  A user who has been given access to view results
  """
  USER_READ

  """
  A user who has been given access to run scans, and manage domains
  """
  USER_WRITE

  """
  A user who has the same access as a user write account, but can define new user write accounts
  """
  ADMIN

  """
  A user who has the same access as an admin, but can define new admins
  """
  SUPER_ADMIN
}

enum ScanTypeEnums {
  """
  Used for defining if DMARC and DKIM scans should be performed
  """
  MAIL

  """
  Used for defining if HTTPS and SSL scans should be performed
  """
  WEB
}

"""
A field that conforms to a list of strings
"""
scalar Selectors

"""
This mutation is used for re-sending a verification email if it failed
during user creation
"""
type SendEmailVerification {
  """
  If email is successfully sent status will be true
  """
  status: Boolean
}

"""
This method allows for new users to sign up for our sites services.
"""
type SignUp {
  """
  Users information, and JWT
  """
  authResult: AuthResult
}
"""
A field whos values contain numbers, letters, dashes, and underscores
"""
scalar Slug

"""
Domain information
"""
type Source {
  """
  Source IP Address
  """
  ipAddress: String @examples(values: ["104.195.80.20"])

  """
  Source Country
  """
  country: String @examples(values: ["US"])

  """
  Reverse DNS (also known as rDNS) uses PTR records to associate IP addresses with domain names
  """
  reverseDns: String @examples(values: [null])

  """
  DMARC base domain
  """
  baseDomain: String @examples(values: [null])
}

"""
Email on the Internet can be forged in a number of ways.  In
particular, existing protocols place no restriction on what a sending
host can use as the "MAIL FROM" of a message or the domain given on
the SMTP HELO/EHLO commands.  Version 1 of the Sender Policy Framework (SPF)
protocol is where ADministrative Management Domains (ADMDs) can explicitly
authorize the hosts that are allowed to use their domain names, and a
receiving host can check such authorization.
"""
type SPF {
  """
  ID of the object
  """
  id: ID

  """
  The domain the scan was run on
  """
  domain: URL @fake(type: domainName)

  """
  The time the scan was initiated
  """
  timestamp: DateTime @fake(type: pastDate)

  """
  The current amount of DNS lookups
  """
  lookups: Int @examples(values: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

  """
  SPF record retrieved during the scan of the given domain
  """
  record: String
    @examples(
      values: [
        "v=spf1 ip4:40.92.0.0/15 ip4:40.107.0.0/16 ip4:52.100.0.0/14 ip4:104.47.0.0/17 ip6:2a01:111:f400::/48 ip6:2a01:111:f403::/48 -all"
        "v=spf1 ip4:198.103.111.114/31 ip4:205.193.224.70 ip4:205.193.224.90 ip4:216.13.57.101 ip4:216.13.57.102 ip4:209.82.9.21 ip4:209.82.9.23 ip4:198.103.112.150/31 ip4:205.192.34.113 ip4:205.192.34.56 ip4:205.192.34.58 -all"
      ]
    )

  """
  Instruction of what a recipient should do if there is not a match to your SPF record.
  """
  spfDefault: String
    @examples(values: ["neutral", "softfail", "include", "fail"])

  """
  Key tags found during SPF scan
  """
  spfGuidanceTags: [String]
    @examples(
      values: [
        "spf1"
        "spf2"
        "spf3"
        "spf4"
        "spf5"
        "spf6"
        "spf7"
        "spf8"
        "spf9"
        "spf10"
        "spf11"
        "spf12"
        "spf13"
      ]
    )
}

"""
SPF report results
"""
type SpfReport {
  """
  SPF domain
  """
  domain: String @examples(values: ["example.com"])

  """
  SPF domain scope (“HELP/EHLO” or “MFROM”)
  """
  scope: String @examples(values: ["mfrom"])

  """
  SPF raw result
  """
  result: String @examples(values: ["softfail"])
}

"""
SSL Scan Object
"""
type SSL {
  """
  The ID of the object
  """
  id: ID

  """
  The domain the scan was run on
  """
  domain: URL @fake(type: domainName)

  """
  The time the scan was initiated
  """
  timestamp: DateTime @fake(type: pastDate)

  """
  Key tags found during scan
  """
  sslGuidanceTags: [String]
    @examples(
      values: ["ssl1", "ssl2", "ssl3", "ssl4", "ssl5", "ssl6", "ssl7", "ssl8"]
    )
}

"""
This class handles the inner nested dict given by key: 'template'.
"""
type Template {
  id: String
  uri: String
  version: Int
}

"""
Mutation allows the modification of domains if domain is updated through
out its life-cycle
"""
type UpdateDomain {
  status: Boolean
}

type UpdateOrganization {
  status: Boolean
}

type UpdateUserPassword {
  user: User
}

type UpdateUserRole {
  status: String
}

"""
A field whose value conforms to the standard URL format as specified in RFC3986:
https://www.ietf.org/rfc/rfc3986.txt.
"""
scalar URL

"""
This object can be queried to retrieve the current logged in users
information or if the user is an org or super admin they can query a user
by their user name
"""
type User implements Node {
  """
  The ID of the object.
  """
  id: ID!

  """
  Email that the user signed up with
  """
  userName: EmailAddress @fake(type: email)

  """
  Name displayed to other users
  """
  displayName: String @fake(type: firstName)

  """
  Users preferred language
  """
  lang: String @examples(values: ["English", "French", "Spanish"])

  """
  Has the user completed two factor authentication
  """
  tfa: Boolean @examples(values: [false, true])

  """
  Has the user verified their account
  """
  emailValidated: Boolean

  """
  Users access to organizations
  """
  affiliations(
    before: String
    after: String
    first: Int
    last: Int
  ): UserAffClassConnection
}

type UserAffClass implements Node {
  user: User

  """
  The organization this affiliation belongs to
  """
  organization: Organizations

  """
  The ID of the object.
  """
  id: ID!

  """
  User's ID
  """
  userId: Int

  """
  User's level of access to a given organization
  """
  permission: RoleEnums
}

type UserAffClassConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [UserAffClassEdge]!
}

"""
A Relay edge containing a `UserAffClass` and its cursor.
"""
type UserAffClassEdge {
  """
  The item at the end of the edge
  """
  node: UserAffClass

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type UserListItem implements Node {
  """
  The ID of the object.
  """
  id: ID!

  """
  The users email address or userName
  """
  userName: EmailAddress @fake(type: email)

  """
  The users display name
  """
  displayName: String @fake(type: firstName)

  """
  Indicates wether or not this user has enabled tfa
  """
  tfa: Boolean @examples(values: [true, false])

  """
  Indicates if this user is an admin of the organization specified in the UserList query
  """
  admin: Boolean @examples(values: [true, false])
}

type UserListItemConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [UserListItemEdge]!
}

"""
A Relay edge containing a `UserListItem` and its cursor.
"""
type UserListItemEdge {
  """
  The item at the end of the edge
  """
  node: UserListItem

  """
  A cursor for use in pagination
  """
  cursor: String!
}

type UserPage implements Node {
  """
  The ID of the object.
  """
  id: ID!

  """
  The users email address or userName
  """
  userName: EmailAddress @fake(type: email)

  """
  The users display name
  """
  displayName: String @fake(type: firstName)

  """
  Indicates the preferred language of this user
  """
  lang: String @examples(values: ["ENGLISH", "FRENCH"])

  """
  Indicates wether or not this user has enabled tfa
  """
  tfa: Boolean

  """
  Has the user verified their account
  """
  emailValidated: Boolean

  """
  Indicates if this user is an admin of the organization specified
  """
  userAffiliations: [UserPageAffiliations]
}

type UserPageAffiliations implements Node {
  """
  The ID of the object.
  """
  id: ID!

  """
  Indicates if this user is an admin of the organization
  """
  admin: Boolean @examples(values: [true, false])

  """
  Indicates which organization this users data is being displayed for
  """
  organization: Acronym @examples(values: ["GC", "ABC", "ASDF", "NSTIR", "BC"])
}

type ValidateTwoFactor {
  user: User
}

"""
Results of HTTPS and SSL scans on domain
"""
type WebScan implements Node {
  """
  The domain the scan was run on
  """
  domain: URL

  """
  The ID of the object.
  """
  id: ID!

  """
  The time the scan was initiated
  """
  timestamp: DateTime
  https: HTTPS
  ssl: SSL
}

type WebScanConnection {
  """
  Pagination data for this connection.
  """
  pageInfo: PageInfo!

  """
  Contains the nodes in this connection.
  """
  edges: [WebScanEdge]!
}

"""
A Relay edge containing a `WebScan` and its cursor.
"""
type WebScanEdge {
  """
  The item at the end of the edge
  """
  node: WebScan

  """
  A cursor for use in pagination
  """
  cursor: String!
}

"""
A field that conforms to a 4 digit integer
"""
scalar Year

"""
Object that contains the fields of each detail table
"""
type TableStructure {
  """
  IP address of sending server
  """
  sourceIpAddress: String @fake(type: ipv4Address)
  """
  Domain from SMTP banner message
  """
  envelopeFrom: String @fake(type: domainName)
  """
  Domains used for SPF validation
  """
  spfDomains: String @fake(type: domainName)
  """
  Domains used for DKIM validation
  """
  dkimDomains: String @fake(type: domainName)
  """
  Pointer to a DKIM public key record in DNS
  """
  dkimSelectors: String @examples(values: ["selector4", "selector1", "none"])
  """
  Total messages related to this record
  """
  totalMessages: Int
    @fake(
      type: number
      options: { minNumber: 0, maxNumber: 5000, precisionNumber: 1 }
    )
  """
  Geographic location of source IP address
  """
  countryCode: String @fake(type: countryCode)
  """
  Owner of ISP for source IP address
  """
  ispOrg: String
  """
  Owner of prefix for source IP address
  """
  prefixOrg: String
  """
  Name of AS for source IP address
  """
  asName: String
  """
  Number of AS for source IP address
  """
  asNum: Int
  """
  Owner of AS for source IP address
  """
  asOrg: String
  """
  Host from reverse DNS of source IP address
  """
  dnsHost: String
  """
  Domain from reverse DNS of source IP address
  """
  dnsDomain: String @fake(type: domainName)
}
